<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wenxc.github.io/</id>
    <title>Wlog</title>
    <updated>2020-11-23T07:27:30.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wenxc.github.io/"/>
    <link rel="self" href="https://wenxc.github.io/atom.xml"/>
    <subtitle>QuickNote</subtitle>
    <logo>https://wenxc.github.io/images/avatar.png</logo>
    <icon>https://wenxc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Wlog</rights>
    <entry>
        <title type="html"><![CDATA[Colab入门]]></title>
        <id>https://wenxc.github.io/post/colab-ru-men/</id>
        <link href="https://wenxc.github.io/post/colab-ru-men/">
        </link>
        <updated>2020-11-10T00:52:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>记录一下Colab的一些基础的问题及设置。距Colab开放已两年之久，配置时遇到一些与之前的教程不符的地方，进行了一些改进。主要参考资料<a href="https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d">Google Colab Free GPU Tutorial</a>，在此基础上修改了一些有出入的地方，实测可行后整理如下。</p>
</blockquote>
<h2 id="简介">简介</h2>
<p>Colab（Colaboratory）是谷歌提供的一款基于Jupyter Notebook开发的免费深度学习云平台，尽管只是开放Notebook这样的交互式Python环境，依然可以通过魔法命令和shell命令执行Python脚本（使用和Jupyter Notebook一致，可以参照<a href="https://blog.csdn.net/zhouchen1998/article/details/100126865">Jupyter教程</a>）。同时，Colab配合谷歌其他的应用如Google Drive（谷歌云盘）等共同使用。它预装了几乎所有主流的机器学习和深度学习框架以及常用的工具库，深度学习框架以TensorFlow为主，其他框架需要自行安装。</p>
<h2 id="启动方式">启动方式</h2>
<p>Colab主要有两种启动方式，一种是从Colab的官网主要打开Notebook（ipynb后缀文件），另一种是通过打开自己的Google Drive并关联Colaboratory直接从云盘打开。（<em>个人喜欢后一种方式量，但是两种方式差别不大但也各有局限性</em>）。</p>
<p>第一种方式，Google搜索Colab或者访问<a href="https://colab.research.google.com/">官网地址</a>。如果你是第一次使用，只能看到一个完全用Jupyter Notebook写成的Welcome笔记本，你的笔记本可以来自硬盘（自行创建，如果直接新建notebook会在Google云盘中自动创建名为<code>Colab Notebooks</code>的文件夹用于默认的Notebook文件存放路径），也可以来自Github（需要授权）或者当即上传（上传的位置决定是否会在时长到达是释放删除）。</p>
<p>第二种方式，没有太大扩展空间但是比较实用。在谷歌云盘存放Notebook的文件夹中新建Notebook使用Colaboratory打开即可。这种方式就不能打开Github等仓库Notebook。</p>
<h2 id="notebook配置">Notebook配置</h2>
<p>打开一个新建的Notebook，会看到Colab的工作界面。</p>
<p>有一些必要的配置内容，如文件名（点击文件名处即可修改，修改后Google云盘中的Notebook文件名会相应同步修改），GPU环境（默认使用CPU打开，点击导航栏的修改-&gt;笔记本设置-&gt;硬件加速器-&gt;GPU即可，点击保存会重新开启一个新的GPU的docker环境作为该Notebook的后端）以及编辑器环境。</p>
<p>配置后测试：！nvidia-smi  #查看CUDA和显存</p>
<p>挂载谷歌云盘：使用云盘的主要目的是保存程序运行的结果到云盘，避免colab自动清除导致数据丢失。</p>
<pre><code class="language-python">from google.colab import drive
drive.mount('/content/drive/')
</code></pre>
<p>运行后结果</p>
<pre><code class="language-python">Mounted at /content/drive/
</code></pre>
<p>也可以手动挂载。</p>
<h2 id="安装深度学习框架和其他包">安装深度学习框架和其他包</h2>
<p>在官方教程中已经有Keras、Tensorflow、Pytorch的安装方法，我平时使用Pytorch比较多，所以这里给出我的Pytorch安装代码。</p>
<pre><code class="language-python">!pip install torch==1.7.0+cu101 torchvision==0.8.1+cu101 torchaudio==0.7.0 -f https://download.pytorch.org/whl/torch_stable.html
</code></pre>
<p>具体的pytorch版本选择可以在pytorch官网查看对应的版本。</p>
<pre><code class="language-python">import torch
print(torch.__version__)
</code></pre>
<p>输出</p>
<pre><code class="language-python">1.7.0+cu101
</code></pre>
<h2 id="其他操作">其他操作</h2>
<ul>
<li>
<p>!ls  !cd  !wegt</p>
</li>
<li>
<p>!git clone url</p>
</li>
<li>
<p>!python train.py</p>
<p>et.al</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<ol>
<li>可以把Colab看成是<strong>一台带有GPU的Ubuntu虚拟机</strong>，只不过我们只能用命令行的方式操作它。你可以选择执行系统命令，亦或是直接编写运行python代码。</li>
<li>挂载完Google Drive，会在虚拟机里生成一个drive文件夹，直接将Google Drive当成是<strong>一块硬盘</strong>即可。访问drive文件夹里的文件，就是在访问你的Google Drive里的文件。</li>
<li>Colab最多连续使用12小时，超过时间系统会强制掐断正在运行的程序并收回占用的虚拟机。（好像再次连接到虚拟机后，虚拟机是被清空的状态，需要重新配置和安装库等等）</li>
<li>请使用科学上网方式</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d">官方教程</a><br>
<a href="https://research.google.com/colaboratory/faq.html">官方FAQ</a><br>
<a href="https://www.cnblogs.com/smiler/p/6939913.html">https://www.cnblogs.com/smiler/p/6939913.html</a><br>
<a href="https://www.cnblogs.com/oxspirt/p/6294754.html"> https://www.cnblogs.com/oxspirt/p/6294754.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pathlib 库中Path使用教程]]></title>
        <id>https://wenxc.github.io/post/pathlib-shi-yong-jiao-cheng/</id>
        <link href="https://wenxc.github.io/post/pathlib-shi-yong-jiao-cheng/">
        </link>
        <updated>2020-09-15T00:43:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>传统上，Python使用常规文本字符串表示文件路径。由于<a href="https://snarky.ca/why-pathlib-path-doesn-t-inherit-from-str/">路径不是字符串</a>，重要的功能是遍布在标准库中的，包括像<a href="https://docs.python.org/3/library/os.html"><code>os</code></a>，<a href="https://docs.python.org/3/library/glob.html"><code>glob</code></a>和<a href="https://docs.python.org/3/library/shutil.html"><code>shutil</code></a>等库。从python3.4以后，pathlib内置，简化文件路径操作，<code>pathlib</code>可以看作<code>os.path</code>功能的一个面向对像化，从Python 3.6开始，添加了文件系统路径协议，整个标准库都支持pathlib模块。这里记录pathlib的Path方法的使用。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>传统上，Python使用常规文本字符串表示文件路径。由于<a href="https://snarky.ca/why-pathlib-path-doesn-t-inherit-from-str/">路径不是字符串</a>，重要的功能是遍布在标准库中的，包括像<a href="https://docs.python.org/3/library/os.html"><code>os</code></a>，<a href="https://docs.python.org/3/library/glob.html"><code>glob</code></a>和<a href="https://docs.python.org/3/library/shutil.html"><code>shutil</code></a>等库。从python3.4以后，pathlib内置，简化文件路径操作，<code>pathlib</code>可以看作<code>os.path</code>功能的一个面向对像化，从Python 3.6开始，添加了文件系统路径协议，整个标准库都支持pathlib模块。这里记录pathlib的Path方法的使用。</p>
</blockquote>
<!-- more -->
<p>pathlib 库的 Path 方法，可以将一个普通的字符串转换为 pathlib.Path 对象类型的路径</p>
<h3 id="path的属性和方法">Path的属性和方法</h3>
<pre><code class="language-python">Path
│
├── Attributes
│       ├── parts
│       ├── parent &amp; parents
│       ├── name
│       ├── suffix &amp; suffixes
│       └── stem
│
│
└── Methods
        ├── joinpath(*other)
        ├── cwd()
        ├── home()
        ├── exists()
        ├── expanduser()
        ├── glob()
        ├── rglob(pattern)
        ├── is_dir()
        ├── is_file()
        ├── is_absolute()
        ├── iterdir()
        ├── mkdir(mode=0o777, parents=False, exist_ok=False)
        ├── open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)
        ├── rename(target)
        ├── replace(target)
        ├── resolve(strict=False)
        └── rmdir()
</code></pre>
<h3 id="创建路径">创建路径</h3>
<pre><code class="language-python">from pathlib import Path
 
now_path = Path.cwd()
home_path = Path.home()
 
print(&quot;当前工作目录&quot;,now_path,type(now_path))
print(&quot;home目录&quot;,home_path,type(home_path))
</code></pre>
<p>输出内容</p>
<pre><code class="language-python">当前工作目录 /Users/chennan/pythonproject/demo &lt;class 'pathlib.WindowsPath'&gt;
home目录 /Users/chennan &lt;class 'pathlib.WindowsPath'&gt;
</code></pre>
<p>或者传统方法，直接传入字符串</p>
<pre><code class="language-python">import pathlib
DIR_PATH = pathlib.Path(&quot;/Users/chennan/CDM&quot;)
print(DIR_PATH,type(DIR_PATH))
</code></pre>
<p>输出内容</p>
<pre><code class="language-python">/Users/chennan/CDM &lt;class 'pathlib.WindowsPath'&gt;
</code></pre>
<p>Path.mkdir(mode=0o777, parents=False, exist_ok=False)</p>
<p>在给定路径下创建新路径。</p>
<ul>
<li>mode:文件的权限控制</li>
<li>parentes:如是是<em>True</em>,那么缺失的路径中的内容都会自动创建，否则会报<em>FileNotFoundError</em>的错</li>
<li>exist_ok:如果是False,那么当路径已经存在时，会报错；当是True时，会忽略报错</li>
</ul>
<pre><code class="language-python">Path(&quot;src/other/side&quot;).mkdir(parents=True)
</code></pre>
<h3 id="读写文件">读写文件</h3>
<p>可以通过“/”直接拼接路径，而且对于Path对象，可以直接使用open操作</p>
<pre><code class="language-python">import pathlib
DIR_PATH = pathlib.Path(&quot;/Users/wenxc/CDM&quot;) / &quot;2000&quot; / &quot;hehe.txt&quot;
with DIR_PATH.open(&quot;r&quot;) as fs:
     data = fs.read() 
print(data) 
</code></pre>
<p>对path对象也可以使用自身的文件读取方式，不再使用with open</p>
<pre><code class="language-python">.read_text(): 找到对应的路径然后打开文件，读成str格式。等同open操作文件的&quot;r&quot;格式。
.read_bytes(): 读取字节流的方式。等同open操作文件的&quot;rb&quot;格式。
.write_text(): 文件的写的操作，等同open操作文件的&quot;w&quot;格式。
.write_bytes(): 文件的写的操作，等同open操作文件的&quot;wb&quot;格式。
</code></pre>
<p>在使用相对路径时</p>
<pre><code class="language-python">import pathlib
py_path =pathlib.Path(&quot;superdemo.py&quot;)
print(py_path.resolve()) 
</code></pre>
<p>输出的是当前文件的相对路径</p>
<h3 id="选择路径的不同组成部分">选择路径的不同组成部分</h3>
<pre><code class="language-python">import pathlib
 
now_path = pathlib.Path.cwd() / &quot;demo.txt&quot;
print(&quot;name&quot;,now_path.name)
print(&quot;stem&quot;,now_path.stem)
print(&quot;suffix&quot;,now_path.suffix)
print(&quot;parent&quot;,now_path.parent)
print(&quot;anchor&quot;,now_path.anchor)
</code></pre>
<p>输出内容如下</p>
<pre><code class="language-python">name demo.txt
stem demo
suffix .txt
parent /Users/wenxc/pythonproject/demo
anchor /
</code></pre>
<h3 id="移动和删除文件">移动和删除文件</h3>
<p>使用 replace 方法可以移动文件，如果文件存在则会覆盖。为避免文件可能被覆盖，最简单的方法是在替换之前测试目标是否存在。</p>
<pre><code class="language-python">import pathlib
 
destination = pathlib.Path.cwd() / &quot;target.txt&quot; 
source = pathlib.Path.cwd() / &quot;demo.txt&quot;
if not destination.exists():
    source.replace(destination)
</code></pre>
<p>但是上面的方法存在问题就是，在多个进程多 destination 进行的操作的时候就会现问题，可以使用下面的方法避免这个问题。也就是说上面的方法适合单个文件的操作。</p>
<pre><code class="language-python">import pathlib
 
destination = pathlib.Path.cwd() / &quot;target.txt&quot; 
source = pathlib.Path.cwd() / &quot;demo.txt&quot;
with destination.open(mode='xb') as fid: 
    #xb表示文件不存在才操作
    fid.write(source.read_bytes())
</code></pre>
<p>当 destination文件存在的时候上面的代码就会出现 FileExistsError 异常。<br>
从技术上讲，这会复制一个文件。 要执行移动，只需在复制完成后删除源即可。<br>
使用 with_name 和 with.shuffix 可以修改文件名字或者后缀。</p>
<pre><code class="language-python">import pathlib
source = pathlib.Path.cwd() / &quot;demo.py&quot;
source.replace(source.with_suffix(&quot;.txt&quot;)) #修改后缀并移动文件，即重命名
#source依旧指向demo.py,不会变为demo.txt, 再次操作时注意区别
</code></pre>
<p>可以使用 .rmdir() 和 .unlink() 来删除文件。</p>
<pre><code class="language-python">import pathlib
 
destination = pathlib.Path.cwd() / &quot;target&quot; 
source = pathlib.Path.cwd() / &quot;demo.txt&quot;
source.unlink()
</code></pre>
<h3 id="统计文件个数">统计文件个数</h3>
<pre><code class="language-python">import pathlib
from collections import Counter
now_path = pathlib.Path.cwd()
gen = (i.suffix for i in now_path.iterdir())
print(Counter(gen))
</code></pre>
<p>根据后缀统计文件夹内的文件数量</p>
<pre><code class="language-python">import pathlib
from  collections import Counter
gen =(p.suffix for p in pathlib.Path.cwd().glob('*.py'))
print(Counter(gen))

</code></pre>
<p>统计py文件的数量</p>
<p>glob和rglob的区别</p>
<pre><code class="language-python">#获取所有src/stuff文件夹下，以.py为后缀的文件
for fname in Path(&quot;src/stuff&quot;).glob(&quot;*.py&quot;):
    print(fname)

src/stuff/__init__.py
src/stuff/submodule.py

# 比如要返回所有src文件夹下以.py为后缀的文件
for fname in Path(&quot;src&quot;).rglob(&quot;*.py&quot;):
    print(fname)
    
src/module.py
src/b.py
src/stuff/__init__.py
src/stuff/submodule.py


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解拉格朗日乘子法和KKT条件]]></title>
        <id>https://wenxc.github.io/post/shen-ru-li-jie-la-ge-lang-ri-cheng-zi-fa-he-kkt-tiao-jian/</id>
        <link href="https://wenxc.github.io/post/shen-ru-li-jie-la-ge-lang-ri-cheng-zi-fa-he-kkt-tiao-jian/">
        </link>
        <updated>2020-05-12T01:32:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>拉格朗日乘子法（Lagrange Multiplier) 和KKT条件是求取有约束条件的优化问题的非常常用而且重要的方法。之前学习的时候，只是直接应用两个方法，没有深入理解为什么要这样去求取最优值？在查找一些资料后，理解整理如下。</p>
</blockquote>
<h2 id="什么是拉格朗日乘子法和kkt条件">什么是拉格朗日乘子法和KKT条件</h2>
<p>通常我们需要求解的最优化问题有如下几类：</p>
<p>(i) 无约束优化问题，可以写为:</p>
<p>​                                      min f(x);</p>
<p>(ii) 有等式约束的优化问题，可以写为:</p>
<p>​                                       min f(x),</p>
<p>​                                       s.t. h<em>i</em>(x) = 0; i =1, ..., n</p>
<p>(iii) 有不等式约束的优化问题，可以写为：</p>
<p>​                                      min f(x),</p>
<p>​                                      s.t. g<em>i</em>(x) &lt;= 0; i =1, ..., n</p>
<p>​                                             h<em>j</em>(x) = 0; j =1, ..., m</p>
<p>对于第(i)类的优化问题，常常使用的方法就是Fermat定理，即使用求取f(x)的导数，然后令其为零，可以求得候选最优值，再在这些候选值中验证；如果是凸函数，可以保证是最优解。</p>
<p>对于第(ii)类的优化问题，常常使用的方法就是拉格朗日乘子法，即把等式约束h<em>i</em>(x)用一个系数与f(x)写为一个式子L(a, x) = f(x) + a*h(x)，称为拉格朗日函数，系数a称为拉格朗日乘子。通过拉格朗日函数对各个变量求导，令其为零，可以求得候选值集合，然后验证求得最优值。</p>
<p>对于第(iii)类的优化问题，常常使用的方法就是KKT条件。同样地，把所有的等式、不等式约束与f(x)写为一个式子L(a, b, x)= f(x) + a<em>g(x)+b</em>h(x)，也叫拉格朗日函数，系数也称拉格朗日乘子。所谓KKT条件就是说优化问题求取的最优值必须满足以下条件：</p>
<ul>
<li>L(a, b, x)对x求导为零；</li>
<li>h(x) =0;</li>
<li>a*g(x) = 0;</li>
</ul>
<p>求取这三个等式之后能得到候选最优值。其中第三个式子非常有趣，因为g(x)&lt;=0，如果要满足这个等式，必须a=0或者g(x)=0. 这是SVM的很多重要性质的来源，如支持向量的概念。</p>
<h2 id="为什么拉格朗日乘子法-和kkt条件能够得到最优值">为什么拉格朗日乘子法 和KKT条件能够得到最优值？</h2>
<p>以维基百科给出的拉格朗日乘子法为例，假设目标函数z = f(x，y),  z取不同的值，则目标函数投影在xOy平面（曲面）上，即成为等高线，如下图，虚线是等高线。假设约束g(x，y)=0，在xOy平面或者曲面上是一条曲线，假设g(x，y)与等高线相交，交点就是同时满足等式约束条件和目标函数的可行域的值，但肯定不是最优值，因为相交意味着肯定还存在其它的等高线在该条等高线的内部或者外部，使得新的等高线与目标函数的交点的值更大或者更小，只有到等高线与目标函数的曲线相切的时候，可能取得最优值，即等高线和目标函数的曲线在该点的法向量必须在一条直线上，所以最优值必须满足：f(x，y)的梯度 = a* g(x，y)的梯度，a是常数，表示左右两边共线。这个等式就是L(a,x)对参数求导的结果。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/11/23/8weFJpos1mOuYLE.jpg" alt="001.jpg" loading="lazy"></figure>
<p>假设现在有不等式约束g ( x , y ) − c ≤ 0，五角星区域是我们满足不等式约束的区域。此时我们仍然用拉格朗日乘法将对不等式约束引入拉格朗日乘法。习惯上对等式约束使用β 乘子，对不等式约束使用α 乘子 L ( x , y , λ ) = f ( x , y ) + λ ⋅ ( g ( x , y ) − c ) 。<br>
我们仍然按照三步求导的战略，仍旧可以得到：</p>
<ul>
<li>f ′ ( x ) = λ g ′ ( x )</li>
<li>f ′ ( y ) = λ g ′ ( y ) g ( x , y ) − c = 0</li>
<li><em>g</em>(<em>x</em>,<em>y</em>)−<em>c</em>=0</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/11/23/jvDyGgRdZNTVe5H.png" alt="002.png" loading="lazy"></figure>
<p>但是这和等式约束有什么区别在于要想最小值点落在约束不等式所在的曲线上，那么原函数的梯度和约束曲线的梯度一定要是反方向的。<br>
也就是</p>
<ul>
<li>f ′ ( x ) + λ g ′ ( x ) = 0</li>
<li>f ′ ( y ) + λ g ′ ( y ) = 0</li>
<li>s . t . λ ≥ 0</li>
</ul>
<p>也就是说如果最优解落在约束曲线上，除了原函数在该点的法向量能被约束曲线线性表出外，原函数的法向量的符号还得和约束曲线们的法向量符号相反，即切点约束条件区域扩大的方向与原函数增大的方向相同。</p>
<p>这就引出<strong>KKT条件</strong>之大部分（除了条件d）：<br>
∇ x L ( x ∗ , α ∗ , β ∗ ) = 0 ( a )</p>
<p>∇ α L ( x ∗ , α ∗ , β ∗ ) = 0 ( b )</p>
<p>∇ β L ( x ∗ , α ∗ , β ∗ ) = 0 ( c )</p>
<p>α i ∗ c i ( x ∗ ) = 0 , i = 1 , 2 , ⋯  k ( d )</p>
<p>c i ( x ∗ ) ≤ 0 , i = 1 , 2 , ⋯  k ( e )</p>
<p>α i ∗ ≥ 0 , i = 1 , 2 , ⋯k ( f )</p>
<p>h j ( x ∗ ) = 0 , j = 1 , 2 , ⋯  l ( g )</p>
<ul>
<li>条件(a)为原函数在切点的法向量被约束曲线在该点的法向量线性表出</li>
<li>（b）(c） 表示最优解落在约束条件所在的曲线上</li>
<li>（e）为约束条件的表达形式，都是小于等于的形式</li>
<li>（f）使得原函数的法向量与约束曲线的法向量在切点处异号</li>
<li>（g）为等式约束的形式</li>
</ul>
<p>而对于多个不等式约束：</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/11/23/ZVTlipqr8eoafkw.png" alt="003" loading="lazy"></figure>
<p>由上图可知，<em>g</em>3函数在约束时没有起任何作用，但是在上面的KKT条件中<em>g</em>3和其对应λ 的系数都参与了运算，如何消除其作用呢，这就引出了KKT的最后一个条件d：<br>
α i ∗ c i ( x ∗ ) = 0 , i = 1 , 2 , ⋯  k ( d )<br>
最优解在约束曲线上时，其表达式为0，若不在某条约束曲线上，为了使最后的结果为0，其系数必须为0，从而使不产生作用的曲线在计算时不产生作用。<strong>该条件也称为KKT的对偶互补条件。</strong><br>
到此为止我们推出了KKT的所有条件。</p>
<h2 id="拉格朗日对偶性">拉格朗日对偶性</h2>
<p>原始问题，求在等式和不等式约束条件下的函数最小值：</p>
<p>​														<img src="https://i.loli.net/2020/11/23/5EH9rP3N2sUaz1F.png" alt="004" loading="lazy"></p>
<p>为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：</p>
<p>​									<img src="https://i.loli.net/2020/11/23/gRspnaLbdkGFu9f.png" alt="005.png" loading="lazy"></p>
<p>其中：</p>
<ul>
<li>f ( x )是可微的</li>
<li>α i , β j 成为拉格朗日乘子且α i ≥ 0</li>
<li>c i ( x ) ≤ 0</li>
<li>h i = 0</li>
</ul>
<p>通过拉格朗日乘法，把约束条件加上新的变量构成了一个新的函数，虽然新的函数中变量变多了，但是没有了限制条件。<br>
考虑x的函数（下标P表示原始问题）：</p>
<p>​																<img src="https://i.loli.net/2020/11/23/wbhSTUg2aPFK8Nn.png" alt="007" loading="lazy"></p>
<p><strong>这个max的意义在于，我们将所有的x样本根据取值的不同分成了满足条件和不满足条件的两部分，用函数的取值代替了原来的约束条件</strong>。</p>
<p>现在这个θ*<em>P*(<em>x</em></em>) 取最大，只要根据x的取值情况来调整其系数α <em>β</em> 即可。x的取值情况有两种：</p>
<ul>
<li>
<p>满足原始问题的约束，这种情况下c i ( x ) ≤ 0 ,h j ( x ) = 0 ,并且α i ≥ 0 ，那我们只要让c i 的拉格朗日系数α为0，就能得到最大的结果f*(<em>x</em>)</p>
</li>
<li>
<p>不满足原始问题的约束，这种情况下要么 c i ( x ) &gt; 0 或者h j ( x ) ≠ 0,那我们就能通过改变α β 使得 θ**P*(<em><strong>x</strong></em>)取到正无穷。</p>
<p>所以我们就有如下的式子：<br>
<img src="https://i.loli.net/2020/11/23/lYKgwJ2zyGvhMcq.png" alt="008" loading="lazy"></p>
</li>
</ul>
<p>再考虑极小化问题：</p>
<p>​														<img src="https://i.loli.net/2020/11/23/RZn8tjfSCB9FTH6.png" alt="009" loading="lazy"></p>
<p>这个问题的解和原问题是等价的，即它和原始问题（带有约束条件的f(x)最小化问题）有着相同的解。因为对 θ P*(<em><strong>x</strong></em>)取最小值，就是对f*(*x)取最小值。</p>
<p>如果我们定义原始问题的最优解为p ∗ ，那么我们也有<br>
<em>p</em>∗=<em>x</em>min <em>θ**P</em>(<em>x</em>)<br>
到这里，我们就将原来带有约束条件的极小化问题，变成了不带约束条件的极小极大问题。到这一步我们还是无法求解，所以我们引入对偶问题，将极小极大问题转化为极大极小问题。</p>
<h2 id="对偶问题">对偶问题</h2>
<p>定义：<br>
<img src="https://i.loli.net/2020/11/23/qypsIkwaHPzj5VJ.png" alt="010.png" loading="lazy"><br>
​																		<br>
之前我们是先求极大值，再求极小值，先求极大值的好处是可以根据结果将数据分为满足条件和不满足条件的两部分，然后再对结果求最小，即变成了对满足条件的x求最小值还原了原始问题。</p>
<p>现在我们反过来，先求极小值再求极大值，将该问题成为原始问题的对偶问题，定义对偶问题的最优值：</p>
<p><em>d</em>∗=<em>α</em>,<em>β</em>max  <em>θ</em>D*(<em>α</em>,*β)</p>
<p>原始问题先固定x，求最优化（极大化）的α β 的解，再确定x（通过极小化）<br>
而对偶问题是先固定α ,β ，求最优化（极小化）的x的解，在确定α,β（通过极大化）</p>
<h3 id="原始问题与对偶问题的关系">原始问题与对偶问题的关系</h3>
<p>我将原始问题的最优解，转化为对偶问题的最优解，如果这两个解是等价的，那么解对偶问题最优解就是我们需要的原始问题的最优解。<br>
若原始问题和对偶问题都有最优值，则：<br>
<img src="https://i.loli.net/2020/11/23/BZjc7bJdxtOhpHi.png" alt="zuiyou.png" loading="lazy"><br>
证明：<br>
对于任意的x , α , β 有：</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/11/23/HJf1ad4CNWiOluB.png" alt="zuiyouzhengming.png" loading="lazy"></figure>
<p>因为上述式子是在任意条件下的x , α , β，最大最小是任意条件中的特殊情况，所以上述结论得证。</p>
<p>对偶问题的解小于等于原始问题的解 d ∗ ≤ p ∗ 。只有当等号成立的时候我们才能通过对偶问题来解决原始问题。对偶问题取等需要二者满足强对偶关系，而后有学者在强对偶下提出了KKT条件，且KKT条件的成立要满足constraint qualifications，而constraint qualifications之一就是Slater条件，即：凸优化问题，如果存在一个点x，使得所有等式约束都成立，并且所有不等式约束都严格成立（即取严格不等号，而非等号）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenCV图片操作]]></title>
        <id>https://wenxc.github.io/post/opencv-tu-pian-cao-zuo/</id>
        <link href="https://wenxc.github.io/post/opencv-tu-pian-cao-zuo/">
        </link>
        <updated>2020-01-15T00:36:51.000Z</updated>
        <summary type="html"><![CDATA[<p>记录OpenCV读取和显示图片的一些基本操作，适合新手入门</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录OpenCV读取和显示图片的一些基本操作，适合新手入门</p>
<!-- more -->
<h3 id="imread">imread</h3>
<pre><code class="language-python">cv2.imread(path_of_image, intflag)
</code></pre>
<p>函数参数一： 需要读入图像的完整的路径<br>
函数参数二： 标志以什么形式读入图像，可以选择一下方式：<br>
<strong>·</strong> <em>cv2.IMREAD_COLOR：</em> 加载彩色图像。任何图像的透明度都将被忽略。它是默认标志<br>
<strong>·</strong> *cv2.IMREAD_GRAYSCALE：*以灰度模式加载图像<br>
<strong>·</strong> *cv2.IMREAD_UNCHANGED：*保留读取图片原有的颜色通道</p>
<p><strong>·</strong> *1 ：*等同于cv2.IMREAD_COLOR<br>
<strong>·</strong> *0 ：*等同于cv2.IMREAD_GRAYSCALE<br>
<strong>·</strong> *-1 ：*等同于cv2.IMREAD_UNCHANGED</p>
<h3 id="imshow">imshow</h3>
<p>imshow函数作用是在窗口中显示图像，窗口自动适合于图像大小，我们也可以通过imutils模块调整显示图像的窗口的大小。函数官方定义如下：</p>
<pre><code class="language-python">cv2.imshow(windows_name, image)
</code></pre>
<p>函数参数一： 窗口名称(字符串)<br>
函数参数二： 图像对象，类型是numpy中的ndarray类型，注：这里可以通过imutils模块改变图像显示大小，下面示例展示</p>
<p>示例：</p>
<pre><code class="language-python">cv2.imshow('origin image', rgb_img)   #显示原图
cv2.imshow('origin image', imutils.resize(rgb_img, 800))  #利用imutils模块调整显示图像大小
cv2.imshow('gray image', imutils.resize(gray_img, 800))
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
</code></pre>
<h3 id="imwrite">imwrite</h3>
<p>imwrite函数检图像保存到本地，官方定义：</p>
<pre><code class="language-python">cv2.imwrite(image_filename, image)
</code></pre>
<p>函数参数一： 保存的图像名称(字符串)<br>
函数参数二： 图像对象，类型是numpy中的ndarray类型</p>
<pre><code class="language-python">cv2.imwrite('rgb_img.jpg', rgb_img)   #将图像保存成jpg文件
cv2.imwrite('gray_img.png', gray_img) #将图像保存成png文件
</code></pre>
<h3 id="窗口销毁函数">窗口销毁函数</h3>
<p>使用imshow函数展示图像时，最后需要在程序中对图像展示窗口进行销毁，否则程序将无法正常终止，常用的销毁窗口的函数有下面两个：<br>
(1) cv2.destroyWindow(windows_name) #销毁单个特定窗口<br>
参数： 将要销毁的窗口的名字</p>
<p>(2) cv2.destroyAllWindows() #销毁全部窗口，无参数</p>
<p>窗口停留有两种方式：<br>
(1) 让窗口停留一段时间然后自动销毁；<br>
(2) 接收指定的命令，如接收指定的键盘敲击然后结束我们想要结束的窗口<br>
以上两种情况都将使用cv2.waitKey函数， 首先产看函数定义：</p>
<pre><code class="language-python">cv2.waitKey(time_of_milliseconds)
</code></pre>
<p>唯一参数 time_of_milliseconds是整数，可正可负也可是零，含义和操作也不同，分别对应上面说的两种情况</p>
<p>(1) time_of_milliseconds &gt; 0 ：此时time_of_milliseconds表示时间，单位是毫秒，含义表示等待 time_of_milliseconds毫秒后图像将自动销毁，看以下示例</p>
<pre><code class="language-python">#表示等待10秒后，将销毁所有图像
if cv2.waitKey(10000):
    cv2.destroyAllWindows()

#表示等待10秒，将销毁窗口名称为'origin image'的图像窗口
if cv2.waitKey(10000):
    cv2.destroyWindow('origin image')
</code></pre>
<p>(2) time_of_milliseconds &lt;= 0 ： 此时图像窗口将等待一个键盘敲击，接收到指定的键盘敲击便会进行窗口销毁。我们可以自定义等待敲击的键盘，通过下面的例子进行更好的解释</p>
<pre><code class="language-python">#当指定waitKey(0) == 27时当敲击键盘 Esc 时便销毁所有窗口
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()

#当接收到键盘敲击A时，便销毁名称为'origin image'的图像窗口
if cv2.waitKey(-1) == ord('A'):
    cv2.destroyWindow('origin image')
</code></pre>
<p>下面是一个完整读取、展示、保存和图像销毁示例：</p>
<pre><code class="language-python">import cv2
import imutils
import numpy as np

rgb_img = cv2.imread('E:/peking_rw/ocr_project/base_prehandle/img/cartoon.jpg')
gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)
cv2.imshow('origin image', imutils.resize(rgb_img, 800))
cv2.imshow('gray image', imutils.resize(gray_img, 800))
cv2.imwrite('rgb_img.jpg', rgb_img)
cv2.imwrite('gray_img.png', gray_img)

#等待一定时间自动销毁图像窗口
#if cv2.waitKey(10000):
#    cv2.destroyAllWindows()
#if cv2.waitKey(10000):
#    cv2.destroyWindow('origin image')

#接收特定键盘销毁图像窗口
#if cv2.waitKey(-1) == ord('A'):
#    cv2.destroyWindow('origin image')
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
</code></pre>
<h3 id="色彩空间变换函数">色彩空间变换函数</h3>
<p>首先图像色彩空间变换函数定义：</p>
<pre><code class="language-text">cv2.cvtColor(input_image, flag)
</code></pre>
<p>参数一： input_image表示将要变换色彩的图像ndarray对象<br>
参数二： 表示图像色彩空间变换的类型，以下介绍常用的两种：<br>
<strong>·</strong> <em>cv2.COLOR_BGR2GRAY：</em> 表示将图像从BGR空间转化成灰度图，最常用<br>
<strong>·</strong> <em>cv2.COLOR_BGR2HSV：</em> 表示将图像从RGB空间转换到HSV空间</p>
<p>如果想查看参数flag的全部类型，可以执行以下程序便可查阅，总共有274种空间转换类型：</p>
<pre><code class="language-python">import cv2
flags = [i for i in dir(cv2) if i.startswith('COLOR_')]
print(flags)
</code></pre>
<h3 id="绘制函数">绘制函数</h3>
<p><strong>1、绘图简单图像</strong></p>
<p>对于一个长宽分别为w、h的RGB彩色图像来说，它的每个像素值是由(B、G、R)的一个tuple组成，opencv-python中每个像素三个值的顺序是B、G、R，而对于灰度图像来说，每个像素对应的便只是一个整数，如果要把像素缩放到0、1，则灰度图像就是二值图像，0便是黑色，1便是白色。</p>
<p>例子：</p>
<pre><code class="language-python">import cv2

rgb_img = cv2.imread('E:/peking_rw/ocr_project/base_prehandle/img/cartoon.jpg')
print(rgb_img.shape)     #(1200, 1600, 3)
print(rgb_img[0, 0])     #[137 124  38]
print(rgb_img[0, 0, 0])  #137

gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)
print(gray_img.shape)    #(1200, 1600)
print(gray_img[0, 0])    #100
</code></pre>
<p>从上面我们可以看到彩色图像的高度height = 1200， 宽度w=1600且通道数为3， 像素(0， 0)的值是(137 124 38)，即R=137, G=124, B=38， 对于灰度图像来说便只是单通道的了</p>
<p>因此(0, 0, 0)便是代表一个黑色像素，(255, 255, 255)便是代表一个白色像素。这么想，B=0, G=0, R=0相当于关闭了颜色通道也就相当于无光照进入，所以图像整个是黑的，而(255, 255, 255)即B=255, G=255, R=255， 相当于打开了B、G、R所有通道光线全部进入，因此便是白色。</p>
<p>通过创建numpy的ndarray对象来创建任意的彩色图像和灰度图像，例如：</p>
<pre><code class="language-python">import cv2
import numpy as np

white_img = np.ones((512,512,3), np.uint8)
white_img = 255*white_img
cv2.imshow('white_img', white_img)
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
</code></pre>
<p>效果图：</p>
<p>opencv中一些简单几何图像基本绘制函数，然后在上面白色的图像上进行添加新的图像物体</p>
<p>直线cv2.line、长方形cv2.rectangle、圆cv2.circle、椭圆cv2.ellipse、多边形cv2.polylines等集合图像绘制函数</p>
<p>它们的公共参数：<br>
<strong>·</strong> <em>img：</em> 表示需要进行绘制的图像对象ndarray<br>
<strong>·</strong> <em>color：</em> 表示绘制几何图形的颜色，采用BGR即上述说的(B、G、R)<br>
<strong>·</strong> <em>thickness：</em> 表示绘制几何图形中线的粗细，默认为1，对于圆、椭圆等封闭图像取-1时是填充图形内部<br>
<strong>·</strong> <em>lineType ：</em> 表示绘制几何图形线的类型，默认8-connected线是光滑的，当取cv2.LINE_AA时线呈现锯齿状</p>
<p>(1) cv2.line函数</p>
<p>直线绘制函数， 函数官方定义为：</p>
<pre><code class="language-text">cv2.line(image, starting, ending, color, thickness, lineType)
</code></pre>
<p>参数image、color、thickness、lineType分别是上述公共定义，参数starting、ending分别表示线的起点像素坐标、终点像素坐标</p>
<p>(2) cv2.rectangle函数</p>
<p>长方形绘制函数，函数官方定义：</p>
<pre><code class="language-text">cv2.rectangle(image, top-left, bottom-right, color, thickness, lineType)
</code></pre>
<p>参数image、color、thickness、lineType分别是上述公共定义，参数top-left、bottom-right分别表示长方形的左上角像素坐标、右下角像素坐标</p>
<p>(3) cv2.circle函数<br>
圆形绘制函数，官方定义函数为：</p>
<pre><code class="language-text">cv2.circle(image, center, radius, color, thickness, lineType)
</code></pre>
<p>参数image、color、thickness、lineType分别是上述公共定义，参数center、radius分别表示圆的圆心像素坐标、圆的半径长度，圆绘制函数中当参数thickness = -1 时绘制的是实心圆，当thickness &gt;= 0 时绘制的是空心圆</p>
<p>(4) cv2.ellipse函数<br>
椭圆绘制函数，官方定义为：</p>
<pre><code class="language-text">cv2.circle(image, center, (major-axis-length, minor-axis-length), angle, startAngle, endAngle, color, thickness, lineType)
</code></pre>
<p>椭圆的参数较多，首先参数image、color、thickness、lineType分别是上述公共定义，椭圆绘制函数中当参数thickness = -1 时绘制的是实心椭圆，当thickness &gt;= 0 时绘制的是空心椭圆，其他参数如下</p>
<p><strong>·</strong> <em>center：</em> 表示椭圆中心像素坐标<br>
<strong>·</strong> <em>major-axis-length：</em> 表示椭圆的长轴长度<br>
<strong>·</strong> <em>minor-axis-length：</em> 表示椭圆的短轴长度<br>
<strong>·</strong> <em>angle：</em> 表示椭圆在逆时针方向旋转的角度<br>
<strong>·</strong> <em>startAngle：</em> 表示椭圆从主轴向顺时针方向测量的椭圆弧的起始角度<br>
<strong>·</strong> <em>endAngle：</em> 表示椭圆从主轴向顺时针方向测量的椭圆弧的终止时角度</p>
<p>(5) cv2.polylines函数<br>
多边形绘制函数，官方定义函数为：</p>
<pre><code class="language-text">cv2.polylines(image, [point-set], flag, color, thickness, lineType)
</code></pre>
<p>参数image、color、thickness、lineType分别是上述公共定义，其他参数如下：</p>
<p><strong>·</strong> <em>[point-set]：</em> 表示多边形点的集合，如果多边形有m个点，则便是一个m<em>1</em>2的数组，表示共m个点<br>
<strong>·</strong> <em>flag：</em> 当flag = True 时，则多边形是封闭的，当flag = False 时，则多边形只是从第一个到最后一个点连线组成的图像，没有封闭</p>
<p>现在我们将上面五种几何图像绘制到开始的白色图像上，观看效果：</p>
<pre><code class="language-text">import cv2
import numpy as np

img = np.ones((512,512,3), np.uint8)
img = 255*img
img = cv2.line(img, (100,100), (400,400),(255, 0, 0), 5)
img = cv2.rectangle(img,(200, 20),(400,120),(0,255,0),3)
img = cv2.circle(img,(100,400), 50, (0,0,255), 2)
img = cv2.circle(img,(250,400), 50, (0,0,255), 0)
img = cv2.ellipse(img,(256,256),(100,50),0,0,180,(0, 255, 255), -1)
pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)
img = cv2.polylines(img,[pts],True,(0, 0, 0), 2)

cv2.imshow('img', img)
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串操作]]></title>
        <id>https://wenxc.github.io/post/zi-fu-chuan-cao-zuo/</id>
        <link href="https://wenxc.github.io/post/zi-fu-chuan-cao-zuo/">
        </link>
        <updated>2019-11-12T00:21:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>从文件里读取字符串踩过的坑。整理一些处理字符的细节，主要记录字符串拼接和分割时的需要注意的地方。</p>
</blockquote>
<p>从txt文件里读取字符串常用函数readlines（）或者readline与for结合迭代构成字符串</p>
<h3 id="除去空格">除去空格</h3>
<pre><code class="language-python">data = ''
with open('test.txt', 'r',encoding='utf-8') as f:
  for line in f.readlines():
    line = line.strip()
    data += line
</code></pre>
<p>这里strip（）删除字符串首尾的空格，除此之外还有lstrip（）和rstrip（）</p>
<pre><code class="language-python"># 删除字符串两边的空格
print(data.strip()) # Hello World

# 删除左边的空格
print(data.lstrip()) # Hello World （只删除左边的空格）

# 删除字符串右边的空格
print(data.rstrip()) #  Hello World（只删除右边的空格）
</code></pre>
<p>不过这些函数无法除去字符中间的空格，如果需要可以使用替代的方法</p>
<pre><code class="language-python">data.replace(' ', '')
</code></pre>
<p>读取文件时还会遇到空字符以及回车等字符，需要从数据中删除这些数据</p>
<h3 id="除去回车">除去回车</h3>
<p>在python中存在继承了 回车符\r 和 换行符\n 两种标记。</p>
<p><code>\r</code>和<code>\n</code> 都是以前的那种打字机传承来的。</p>
<p><code>\r</code> 代表回车，也就是打印头归位，回到某一行的开头。</p>
<p><code>\n</code>代表换行，就是走纸，下一行。</p>
<p>linux只用<code>\n</code>换行。</p>
<p>win下用<code>\r\n</code>表示换行。</p>
<p>python中同样一句话：<code>print (u'前面的内容\r只显示后面的内容')</code></p>
<p>所以，在去除换行时，需要同时去除两者才行</p>
<pre><code class="language-python">data.replace('\n', '').replace('\r', '')
</code></pre>
<h3 id="除去列表中的空字符">除去列表中的空字符</h3>
<p>在实际计算时空字符也会对结果产生影响</p>
<pre><code class="language-python">line = &quot;f 1312/1425/1312 1/1/1 1310/1423/1310 1309/1422/1309 &quot;
line.replace(&quot; &quot;,&quot;,&quot;).split(&quot;,&quot;)
['f', '1312/1425/1312', '1/1/1', '1310/1423/1310', '1309/1422/1309', '']

</code></pre>
<p>在最后的结果里存在这样的空字符参与运算，导致结果错误，可以从列表中除去空字符</p>
<pre><code class="language-python">list1 = ['122', '2333', '3444', '', '', None]
a = list(filter(None, list1))  # 只能过滤空字符和None
print(a)  
# ['122', '2333', '3444']

# Python内建filter()函数 - 过滤list
# filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素
def not_empty(s):
    return s and s.strip()
 
list2 = ['122', '2333', '3444', ' ', '422', ' ', '    ', '54', ' ', '', None, '   ']
print(list(filter(not_empty, list2)))  
['122', '2333', '3444', '422', '54']
# 不仅可以过滤空字符和None而且可以过滤含有空格的字符
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习笔记]]></title>
        <id>https://wenxc.github.io/post/shu-ju-jie-gou-xue-xi-bi-ji/</id>
        <link href="https://wenxc.github.io/post/shu-ju-jie-gou-xue-xi-bi-ji/">
        </link>
        <updated>2019-10-03T14:01:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习记录，监督自己学习，持续更新中</p>
</blockquote>
<!---more--->
<h3 id="抽象数据类型">抽象数据类型</h3>
<p>1、抽象数据类型概念</p>
<p>c语言中数据类型可以分为两类：</p>
<ul>
<li>原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。</li>
<li>结构类型:  由若干个类型组合而成，是可以再分解的，例如整型数组是由若干个整型数据组成的。</li>
</ul>
<p>抽象是指抽取事物具有的普遍性的本质。对已有的数据类型进行抽象就有了抽象数据类型。</p>
<p>抽象数据类型（abstract  data type, ADT）是指一个数学模型及定义在该模型上的一组操作。“抽象”的意义在于数据类型的数学抽象特性，而且抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型。</p>
<p>2、抽象数据类型格式</p>
<p>标准格式：</p>
<p>ADT    抽象数据类型名</p>
<p>data</p>
<p>​		数据元素之间的逻辑关系</p>
<p>operation</p>
<p>​		操作</p>
<p>endADT</p>
<p>线性表的抽象数据类型</p>
<p>ADT 线性表（list）</p>
<p>data</p>
<p>​		线性表的数据对象集合{}，每个元素的类型均为DataType。</p>
<p>operation</p>
<p>​		InitList（*L）：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python调用动态链接库DLL学习笔记]]></title>
        <id>https://wenxc.github.io/post/python-diao-yong-dong-tai-lian-jie-ku-dll-xue-xi-bi-ji/</id>
        <link href="https://wenxc.github.io/post/python-diao-yong-dong-tai-lian-jie-ku-dll-xue-xi-bi-ji/">
        </link>
        <updated>2019-09-09T14:05:51.000Z</updated>
        <content type="html"><![CDATA[<h4 id="python调用动态链接库dll">Python调用动态链接库DLL</h4>
<p>动态链接库（DLL，全称Dynamic Link Library）进程之间共享使用的函数库。动态链接库提供了一种方法，是进程可以调用不属于其自身可执行代码的函数。函数的可执行代码位于一个DLL中，当调用DLL中的方法时，进程由原本自身的代码执行到DLL中。DLL有助于程序模块化，减少重复开发。</p>
<!---more--->
<h5 id="概述">概述：</h5>
<p>接触dll之前觉得它很神秘，就像是一个黑盒子，静静地躺在安装的程序的某一个文件夹内，既不能直接运行，也不能接收消息，但离了他们程序往往又无法运行。动态链接库是一些独立的文件，其中包含能被可执行程序或其他dll调用来完成某项工作的函数，只有在其他模块调用dll中的函数时，dll才发挥作用。<br>
在实际编程中，我们可以把完成某项功能的函数放在一个动态链接库里，然后提供给其他程序调用。像Windows API中所有的函数都包含在dll中，如Kernel32.dll, User32.dll, GDI32.dll等。那么dll究竟有什么好处呢？</p>
<h5 id="语法">语法：</h5>
<p>__declspec(dllexport):<br>
将一个函数声名为导出函数，就是说这个函数要被其他程序调用，即作为DLL的一个对外函数接口。<br>
通常它和extern    &quot;C&quot;   合用，extern &quot;C&quot;告诉编译器该部分可以在C/C++中使用，形式如下：<br>
extern &quot;C&quot;<br>
{</p>
<p>__declspec(dllexport) RETURN_TYPE FUNCTION()</p>
<p>}</p>
<p>__declspec(dllimport) :</p>
<p>当你需要使用DLL中的函数时，往往不需要显示地导入函数，编译器可自动完成。但如果你显示地导入函数，编译器会产生质量更好的代码。由于编译器确切地知道了一个函数是否在一个DLL中，它就可以产生更好的代码，不再需要间接的调用转接。</p>
<p>Win32的PE格式（Portable Executable Format）把所有导入地址放在一个导入地址表中。<a href=""></a></p>
<p>__declspec(dllimport) void func1(void);</p>
<p>void main(void)<br>
{<br>
func1();<br>
}</p>
<h5 id="流程">流程：</h5>
<ul>
<li>
<p><strong>加载DLL</strong></p>
<p>根据调用的函数是符合什么调用约定</p>
<p>stdcall调用约定：两种加载方式</p>
<pre><code class="language-python">Objdll = ctypes.windll.LoadLibrary(&quot;dllpath&quot;)
Objdll = ctypes.WinDLL(&quot;dllpath&quot;) 
</code></pre>
<p>cdecl调用约定：也有两种加载方式</p>
<pre><code class="language-python">Objdll = ctypes.cdll.LoadLibrary(&quot;dllpath&quot;)
Objdll = ctypes.CDLL(&quot;dllpath&quot;)
</code></pre>
<p>windll和cdll分别是WinDLL类和CDll类的对象</p>
</li>
<li>
<p><strong>调用DLL中的函数</strong></p>
<p>在前面加载dll的时候会返回一个DLL对象（假设名字叫Objdll），利用该对象就可以调用dll中的方法。<br>
e.g. 如果dll中有个方法名字叫Add（注意如果经过stdcall声明的方法，如果不是用def文件声明的导出函数或者extern “C” 声明的话，编译器会对函数名进行修改，这个要注意。）<br>
调用：nRet = Objdll.Add(12, 15) 即完成一次调用。</p>
<p>看起来调用似乎很简单，这是因为Add这个函数太简单了，现在假设函数需要你传入一个int类型的指针（int*），可以通过库中的byref关键字来实现，假设现在调用的函数的第三个参数是个int类型的指针。</p>
<pre><code class="language-python">intPara = c_int(9)
dll.sub(23, 102, byref(intPara))
print intPara.value
</code></pre>
<p>如果是要传入一个char缓冲区指针，和缓冲区长度，方法至少有四种：</p>
<pre><code class="language-python"># 方法1
szPara = create_string_buffer('/0'*100)
dll.PrintInfo(byref(szPara), 100);
print szPara.value
 
# 方法2
sBuf = 'aaaaaaaaaabbbbbbbbbbbbbb'
pStr = c_char_p( )
pStr.value = sBuf
#pVoid = ctypes.cast( pStr, ctypes.c_void_p ).value
dll.PrintInfo(pStr, len(pStr.value))
print pStr.value
 
# 方法3
strMa = &quot;/0&quot;*20
FunPrint  = dll.PrintInfo
FunPrint.argtypes = [c_char_p, c_int]
#FunPrint.restypes = c_void_p
nRst = FunPrint(strMa, len(strMa))
print strMa,len(strMa)
 
# 方法4
pStr2 = c_char_p(&quot;/0&quot;)
print pStr2.value
#pVoid = ctypes.cast( pStr, ctypes.c_void_p ).value
dll.PrintInfo(pStr2, len(pStr.value))
print pStr2.value
</code></pre>
</li>
<li>
<p><strong>C基本类型和ctypes中实现的类型映射表</strong></p>
<p>ctypes数据类型          C数据类型<br>
c_char                          char<br>
c_short                         short<br>
c_int                             int<br>
c_long                          long<br>
c_ulong                        unsign long<br>
c_float                          float<br>
c_double                      double<br>
c_void_p                       void<br>
对应的指针类型是在后面加上&quot;_p&quot;，如int*是c_int_p等等。<br>
在python中要实现c语言中的结构，需要用到类。</p>
</li>
<li>
<p><strong>DLL中的函数返回一个指针</strong></p>
<p>虽然这不是一个常用的方法，不过这种情况的处理方法也很简单，其实返回的都是地址，把他们转换相应的python类型，再通过value属性访问。</p>
<pre><code class="language-python">pchar = dll.getbuffer()
szbuffer = c_char_p(pchar)
print szbuffer.value
</code></pre>
</li>
<li>
<p><strong>处理C中的结构体类型</strong></p>
<p>这是最麻烦也是最复杂的一种调用，在python里面申明一个类似c的结构体，要用到类，并且这个类必须继承自Structure。<br>
先看一个简单的例子：<br>
C里面dll的定义如下：</p>
<pre><code class="language-c">typedef struct _SimpleStruct
{
    int    nNo;
    float  fVirus;
    char   szBuffer[512];
} SimpleStruct, *PSimpleStruct;
typedef const SimpleStruct*  PCSimpleStruct;
 
extern &quot;C&quot;int  __declspec(dllexport) PrintStruct(PSimpleStruct simp);
int PrintStruct(PSimpleStruct simp)
{
    printf (&quot;nMaxNum=%f, szContent=%s&quot;, simp-&gt;fVirus, simp-&gt;szBuffer);
return simp-&gt;nNo;
}
</code></pre>
<p>python中的定义：</p>
<pre><code class="language-python">from ctypes import *
class SimpStruct(Structure):
    _fields_ = [ (&quot;nNo&quot;, c_int),
              (&quot;fVirus&quot;, c_float),
              (&quot;szBuffer&quot;, c_char * 512)]
 
dll = CDLL(&quot;AddDll.dll&quot;)
simple = SimpStruct();
simple.nNo = 16
simple.fVirus = 3.1415926
simple.szBuffer = &quot;magicTong/0&quot;
print dll.PrintStruct(byref(simple))
</code></pre>
<p>上面例子结构体很简单，但是如果结构体里面有指针，甚至是指向结构体的指针，处理起来会复杂很多，不过Python里面也有相应的处理方法，下面这个例子来自网上<br>
C代码如下：</p>
<pre><code class="language-c++">typedef struct 

{

char words[10];

}keywords;

 

typedef struct 

{

keywords *kws;

unsigned int len;

}outStruct;

extern &quot;C&quot; int __declspec(dllexport) test(outStruct *o);

int test(outStruct *o)

{

unsigned int i = 4;

o-&gt;kws = (keywords *)malloc(sizeof(unsigned char) * 10 * i);

strcpy(o-&gt;kws[0].words, &quot;The First Data&quot;);

strcpy(o-&gt;kws[1].words, &quot;The Second Data&quot;);

 

o-&gt;len = i;

return 1;

}
</code></pre>
<p>Python代码如下：</p>
<pre><code class="language-python">class keywords(Structure):
 
        _fields_ = [('words', c_char *10),]
 
 
 
class outStruct(Structure):
 
        _fields_ = [('kws', POINTER(keywords)),
 
                    ('len', c_int),]
 
o = outStruct()
 
dll.test(byref(o))
 
 
 
print o.kws[0].words;
 
print o.kws[1].words;
 
print o.len
</code></pre>
</li>
<li>
<p>两个例子</p>
<ul>
<li>这是一个GUID生成器，其实很多第三方的python库已经有封装好的库可以调用，不过这得装了那个库才行，如果想直接调用一些API，对于python来说，也要借助一个第三方库才行，这个例子比较简单，就是用C++调用win32 API来产生GUID，然后python通过调用C++写的dll来获得这个GUID。<br>
c++代码如下：</li>
</ul>
<pre><code class="language-c++">extern &quot;C&quot;__declspec(dllexport) char* newGUID(); 
 
char* newGUID() 
 
{
 
     static char buf[64] = {0};
 
     statc GUID guid;
 
     if (S_OK == ::CoCreateGuid(&amp;guid)) 
 
     {
 
       _snprintf(buf, sizeof(buf),
 
&quot;%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X&quot;, 
 
guid.Data1,
 
guid.Data2,
 
guid.Data3,
 
guid.Data4[0], guid.Data4[1],
 
guid.Data4[2], guid.Data4[3],
 
guid.Data4[4], guid.Data4[5],
 
guid.Data4[6], guid.Data4[7]
 
); 
 
       ::MessageBox(NULL, buf, &quot;GUID&quot;, MB_OK); 
 
      }
 
     return (char*)buf;
 
}

</code></pre>
<p>python代码如下：</p>
<pre><code class="language-python">def CreateGUID():
 
    &quot;&quot;&quot;
    创建一个全局唯一标识符
    类似：E06093E2-699A-4BF2-A325-4F1EADB50E18
    NewVersion
    &quot;&quot;&quot;
 
    try:
 
        # dll path
 
        strDllPath = sys.path[0] + str(os.sep) + &quot;createguid.dll&quot;
 
        dll = CDLL(strDllPath)
 
        b = dll.newGUID()
 
        a = c_char_p(b)
 
    except Exception, error:
 
        print error
 
        return &quot;&quot;
 
    return a.value
</code></pre>
<ul>
<li>
<p>这个例子是调用kernel32.dll中的createprocessA函数来启动一个记事本进程</p>
<pre><code class="language-python">#  -*- coding:utf-8 -*- 
 
from ctypes import * 
 
 
 
# 定义_PROCESS_INFORMATION结构体
 
class _PROCESS_INFORMATION(Structure):
 
    _fields_ = [('hProcess', c_void_p),
 
                ('hThread', c_void_p),
 
                ('dwProcessId', c_ulong),
 
                ('dwThreadId', c_ulong)]
 
 
 
# 定义_STARTUPINFO结构体
 
class _STARTUPINFO(Structure):
 
    _fields_ = [('cb',c_ulong),
 
                ('lpReserved', c_char_p),
 
                ('lpDesktop', c_char_p),
 
                ('lpTitle', c_char_p),
 
                ('dwX', c_ulong),
 
                ('dwY', c_ulong),
 
                ('dwXSize', c_ulong),
 
                ('dwYSize', c_ulong),
 
                ('dwXCountChars', c_ulong),
 
                ('dwYCountChars', c_ulong),
 
                ('dwFillAttribute', c_ulong),
 
                ('dwFlags', c_ulong),
 
                ('wShowWindow', c_ushort),
 
                ('cbReserved2', c_ushort),
 
                ('lpReserved2', c_char_p),
 
                ('hStdInput', c_ulong),
 
                ('hStdOutput', c_ulong),
 
                ('hStdError', c_ulong)]
 
 
 
NORMAL_PRIORITY_CLASS = 0x00000020 #定义NORMAL_PRIORITY_CLASS
 
kernel32 = windll.LoadLibrary(&quot;kernel32.dll&quot;)  #加载kernel32.dll
 
CreateProcess = kernel32.CreateProcessA   #获得CreateProcess函数地址
 
ReadProcessMemory = kernel32.ReadProcessMemory #获得ReadProcessMemory函数地址
 
WriteProcessMemory = kernel32.WriteProcessMemory #获得WriteProcessMemory函数地址
 
TerminateProcess = kernel32.TerminateProcess
 
 
 
# 声明结构体
 
ProcessInfo = _PROCESS_INFORMATION()
 
StartupInfo = _STARTUPINFO()
 
fileName = 'c:/windows/notepad.exe'       # 要进行修改的文件
 
address = 0x0040103c        # 要修改的内存地址
 
strbuf = c_char_p(&quot;_&quot;)        # 缓冲区地址
 
bytesRead = c_ulong(0)       # 读入的字节数
 
bufferSize =  len(strbuf.value)     # 缓冲区大小
 
 
 
# 创建进程 
 
CreateProcess(fileName, 0, 0, 0, 0, NORMAL_PRIORITY_CLASS,0, 0, byref(StartupInfo), byref(ProcessInfo))
</code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo博客使用经验]]></title>
        <id>https://wenxc.github.io/post/hexo-bo-ke-shi-yong-jing-yan/</id>
        <link href="https://wenxc.github.io/post/hexo-bo-ke-shi-yong-jing-yan/">
        </link>
        <updated>2019-09-03T13:53:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>hexo博客编辑过程中遇到的问题以及解决办法</p>
</blockquote>
<!--- more --->
<h3 id="图片插入">图片插入</h3>
<blockquote>
<p>图片资源的路径一直是一个令人头疼的问题，有时候即使在本地浏览器浏览图片正常，但部署到github后也会找不到图片。经过尝试，找到2种解决图片路径问题的方法。</p>
</blockquote>
<h3 id="图床">图床</h3>
<p>所谓图床，就是储存图片的服务器，支持创建图片的对外链接地址便于引用。使用时只要引入图片的绝对地址就可以，方便简单。</p>
<p>图床分为免费和收费的。无免费图床存在隐患，随时可能停止服务；收费图床稳定一些，不管从服务还是稳定性上，都更推荐收费图床。</p>
<p>目前大家推荐比较多的国内图床：</p>
<ul>
<li>七牛云储存<br>
新注册用户可免费使用 10G 存储空间。</li>
<li>极简图床<br>
其实也是依赖七牛云储存账号的。</li>
</ul>
<h3 id="本地图片">本地图片</h3>
<p>本地存放图片的方法经过修改以后也是可以完美使用。</p>
<p>首先修改 <em>站点配置文件</em></p>
<p><code>post_asset_folder: true</code></p>
<p>开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。</p>
<p>再执行 <code>hexo new &lt;title&gt;</code> 创建一篇名为title新的文章，在 source/_posts 下自动生成了一个和 md 文件同名的目录，这就是用于存放与文章有关的图片文件夹。</p>
<p>在根目录下执行：</p>
<p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>
<p>然后在 markdown 中插入图片：</p>
<p><code>! [图片描述] (title/image.png)</code></p>
<p>生成的页面中图片引用路径:</p>
<p><code>&lt;img src=&quot;/YYYY/MM/DD/title/image.png&quot; alt=&quot;图片描述&quot;&gt;</code></p>
<p>至此，用 markdown 实现本地图片插入。</p>
<h3 id="live2d">live2d</h3>
<p>next自带主题的看板娘关闭</p>
<p>主题自带的看板娘存储路径与自定义的大不相同，所以 直接<code>npm uninstall hexo-helper-live2d</code></p>
<h3 id="网站数据统计不能正常工作">网站数据统计不能正常工作</h3>
<p>这是由于busuanzi(不蒜子)的网址更新,导致了使用Hexo Next主题的统计浏览数失效。</p>
<p>解决方法:<br>
打开\themes\next\layout_third-party\analytics文件夹<br>
编辑 busuanzi-counter.swig<br>
将src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”<br>
修改为src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”</p>
<p>busuanzi就能正常工作.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python第三方库制作]]></title>
        <id>https://wenxc.github.io/post/python-di-san-fang-ku-zhi-zuo/</id>
        <link href="https://wenxc.github.io/post/python-di-san-fang-ku-zhi-zuo/">
        </link>
        <updated>2019-08-20T10:25:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>做网格模型操作的python第三方库，还在补充完善。</p>
</blockquote>
<!--- more-->
<h3 id="文件结构">文件结构</h3>
<pre><code>|--smart
|  |--static
|  |  |--icon.svg
|  |  |--confg.json
|  |--engine
|  |  |--__init__.py
|  |  |--core.py
|  |--__init__.py
|  |--__version__.py
|  |--api.py
|  |--utils.py
|--tests
|  |--__init__.py
|--LICENSE
|--README.rst
|--setup.py 
</code></pre>
<p>smart: 作为项目核心代码模块，提供所有的对外接口和实现。其内部可以包含子模块和静态文件<br>
tests: 包含所有的测试用例<br>
LICENSE: 编写相关版权信息<br>
README: 提供项目基本描述和相关使用方法介绍等<br>
setup.py: 项目的安装配置文件</p>
<hr>
<h3 id="setuppy-配置">setup.py 配置</h3>
<p>setup.py 主要使用setuptools的setup模块，提供打包所需要的基本信息。python依赖此脚本中的配置信息。将相关模块、静态文件，打包成一个完整的模块安装到site-packages文件。</p>
<p>基本示例：</p>
<pre><code># 需要将那些包导入
packages = [&quot;smart&quot;, &quot;smart.engine&quot;]

# 导入静态文件
file_data = [
    (&quot;smart/static&quot;, [&quot;smart/static/icon.svg&quot;, &quot;smart/static/config.json&quot;]),
]

# 第三方依赖
requires = [
    &quot;pandas&gt;=0.23.4&quot;
]

# 自动读取version信息
about = {}
with open(os.path.join(here, 'smart', '__version__.py'), 'r', 'utf-8') as f:
    exec(f.read(), about)

# 自动读取readme
with open('README.rst', 'r', 'utf-8') as f:
    readme = f.read()

setup(
    name=about[&quot;__title__&quot;],  # 包名称
    version=about[&quot;__version__&quot;],  # 包版本
    description=about[&quot;__description__&quot;],  # 包详细描述
    long_description=readme,   # 长描述，通常是readme，打包到PiPy需要
    author=about[&quot;__author__&quot;],  # 作者名称
    author_email=about[&quot;__author_email__&quot;],  # 作者邮箱
    url=about[&quot;__url__&quot;],   # 项目官网
    packages=packages,    # 项目需要的包
    data_files=file_data,   # 打包时需要打包的数据文件，如图片，配置文件等
    include_package_data=True,  # 是否需要导入静态数据文件
    python_requires=&quot;&gt;=3.0, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3*&quot;,  # Python版本依赖
    install_requires=requires,  # 第三方库依赖
    zip_safe=False,  # 此项需要，否则卸载时报windows error
    classifiers=[    # 程序的所属分类列表
        'Development Status :: 5 - Production/Stable',
        'Intended Audience :: Developers',
        'Natural Language :: English',
        'Programming Language :: Python',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.4',
        'Programming Language :: Python :: 3.5',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: Implementation :: CPython',
        'Programming Language :: Python :: Implementation :: PyPy'
    ],
)
</code></pre>
<hr>
<h3 id="安装">安装</h3>
<ul>
<li>
<p>打包之前，可以先验证setup.py的正确性</p>
<pre><code>python setup.py check
</code></pre>
<p>如果没有任何错误或者警告，则说明您的setup.py是没问题的<br>
如果没有问题，就可以使用下方的命令正式打包</p>
<pre><code>python setup.py sdist
</code></pre>
<p>打包完成后，会在顶层目录下生产dist和egg两个目录</p>
</li>
<li>
<p>如果您的代码包仅供内部使用，又不想直接发送源码，则可以将代码打包成whl文件<br>
打包成whl命令</p>
<pre><code># --wheel-dir: 为打包存储的路径 
# 空格后为需要打包的工程路径
pip wheel --wheel-dir=D:\\work\\base_package\\dist D:\\work\\base_package
</code></pre>
<p>打包完成后就可以看到<code>smart-0.0.1-py3-none-any.whl</code>文件了，将此文件分享后后，对方就可以使用</p>
<pre><code>pip install smart-0.0.1-py3-none-any.whl
</code></pre>
<p>来安装当前库。</p>
</li>
</ul>
<h3 id="上传">上传</h3>
<p>如果您希望将代码包放到网络上，供所有人开放下载，可以将代码打包上传至PyPi。<br>
上传代码之前，需要到官网注册pypi账户。https://pypi.org/</p>
<ul>
<li>
<p>直接上传</p>
<p>使用<code>register</code>命令是最简单的上传方式，但是使用HTTP并未加密，有可能会泄露密码。</p>
</li>
</ul>
<pre><code>  # 注册包
  python setup.py register
  # 上传包
  python setup.py sdist upload
</code></pre>
<ul>
<li>使用twine上传</li>
</ul>
<ol>
<li>安装twine</li>
</ol>
<pre><code>pip install twine
</code></pre>
<p>​	2.使用twine注册并上传代码</p>
<pre><code># 注册包
twine register dist/smart.whl
# 上传包
twine upload dist/*
</code></pre>
<h3 id="编写模块">编写模块</h3>
<h4 id="1-模块是程序">1. 模块是程序</h4>
<p>模块的本质是一个扩展名为.py的python程序。在使用时直接将函数引用过来，节省精力，不需要写雷同的代码。</p>
<p>但想把自己的.py文件作为模块import过来，必须先让python解释器能够找到你写的模块。比如，在某一目录下，写了这样一个文件：</p>
<pre><code class="language-python"># coding=utf-8
 
display = &quot;hello world! &quot;
</code></pre>
<p>并把它命名为hw.py|，那么这个文件可以作为一个模块被引入，但得首先告诉python解释器我写了一个这样的文件。</p>
<pre><code class="language-python">&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.path.append(&quot;&quot;C:\\Users\\wenxc\\Desktop\\hw.py&quot;&quot;)
</code></pre>
<p>然后把文件作为模块引入</p>
<pre><code class="language-python">&gt;&gt;&gt; import hw

&gt;&gt;&gt; hw.display

'helloworld!'
</code></pre>
<p>这时可以在源路径下看到python模块文件和 _ pycache _ 文件夹。</p>
<blockquote>
<p>在 Python 中，解释器将.py 的文件转化为.pyc 文件，而.pyc 文件是由字节码（bytecode）构成的，然后这个.pyc 文件交给一个叫作 Python 虚拟机的东西去运行（那些号称编译型的语言也是这个流程，不同的是它们先有一个明显的编译过程，编译好了之后再运行）。如果.py 文件修改了，Python 解释器会重新编译，只是这个编译过程不全显示给你看。</p>
<p>有了.pyc 文件后，每次运行就不需要重新让解释器来编译.py 文件了，除非.py 文件修改了。这样，Python 运行的就是那个编译好了的.pyc 文件。</p>
</blockquote>
<p>平时在写有关程序然后执行时常常要用到 if __ name __ == &quot;__ main __&quot;，那时我们直接用&quot;python filename.py&quot;的格式来运行该文件，此时我们也有了同样的,py文件，不过是作为模块引入的。接下来探究一下，同样是.py文件，它怎么知道是被当作程序执行还是被当作模块引入？</p>
<p>先将hw.py文件改造：</p>
<pre><code class="language-python"># coding=utf-8

def display():

    return &quot;hello world !&quot;

if __name__ == &quot;__main__&quot;:

    print(display())
</code></pre>
<p>沿用之前的做法：</p>
<pre><code class="language-python">$ python pm.py

hello world !
</code></pre>
<p>如果将这个程序作为模块导入，会是这样：</p>
<pre><code class="language-python">&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.path.append(&quot;C:\\Users\\wenxc\\Desktop\\hw.py&quot;)

&gt;&gt;&gt; import hw

&gt;&gt;&gt; hw.display()

'hello world !'
</code></pre>
<p>查看模块的属性和方法可以用dir()</p>
<pre><code class="language-python">&gt;&gt;&gt; dir(hw)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'display']
</code></pre>
<p>同样的一个.py文件，可以把它当作程序来执行，也可以把它当作模块引入</p>
<pre><code class="language-python">&gt;&gt;&gt; __name__
'__main__'
&gt;&gt;&gt; hw.__name__
'hw'

</code></pre>
<p>如果要作为程序执行则 __ name__ == &quot; __ main __ &quot;；如果作为模块引入，则hw. __ name __ == &quot;hw&quot;，即变量 __ name __ 的值是模块名称。这是一种简单的区分执行程序还是模块引入的方法。在一般情况下，如果仅仅是用作模块引入，不必写 if __ name __ == &quot;__ main __&quot;。</p>
<h4 id="2模块的位置">2.模块的位置</h4>
<p>在前面的过程中，为了让自己写的模块能够被python解释器知道，需要用sys.path.append()，</p>
<pre><code class="language-python">&gt;&gt;&gt; import pprint
&gt;&gt;&gt; pprint.pprint(sys.path)
['',
 'C:\\Users\\wenxc\\python37.zip',
 'C:\\Users\\wenxc\\DLLs',
 'C:\\Users\\wenxc\\lib',
 'C:\\Users\\wenxc',
 'C:\\Users\\wenxc\\AppData\\Roaming\\Python\\Python37\\site-packages',
 'C:\\Users\\wenxc\\lib\\site-packages',
 'C:\\Users\\wenxc\\Desktop\\hw.py']

</code></pre>
<p>将模块化的文件放到指定位置是一种不错的方法，当然也能用 sys.path.append() ，不管把文件放在哪里，都可以把其位置告诉 Python 解释器。虽然这种方法在前面用了，但其实是很不常用的，因为它也有麻烦的地方，比如在交互模式下，如果关闭了，再开启，还得重新告知。比较常用的方法是设置 PYTHONPATH 环境变量。</p>
<p>环境变量设置，建立一个目录，然后将自己的》py文件放到这里，并设置环境变量。</p>
<h4 id="3-__-all-__在模块中的作用">3. __ all __在模块中的作用</h4>
<p>前面的内容虽然都比较简单，但已经显示了编写模块以及在程序中导入模块的基本方式。在实践中，所编写的模块要更复杂，涉及的变量类型也更多。</p>
<pre><code class="language-python"># coding:utf-8


public_variable = &quot;Hello, I am a public variable.&quot;

_private_variable = &quot;Hi, I am a private variable.&quot;


def public_teacher():

    print(&quot;I am a public teacher, I am from JP.&quot;)


def _private_teacher():

    print(&quot;I am a private teacher, I am from CN.&quot;)

</code></pre>
<p>接下来重复之前的操作</p>
<pre><code class="language-python">&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.path.append(&quot;C:\\Users\\wenxc\\Desktop\\mz.py&quot;)

&gt;&gt;&gt; import pp

&gt;&gt;&gt; from mz import *

&gt;&gt;&gt; public_variable()

'Hello, I am a public variable.'

&gt;&gt;&gt; _private_variable()

Traceback (most recent call last):

  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;

NameError: name '_private_variable' is not defined

</code></pre>
<p>变量 public_variable 能够被使用，但是另外一个变量 _private_variable 不能被调用，先观察一下两者的区别，后者是以单下画线开头的，这样的是私有变量。而 from pp import * 的含义是“希望能访问模块（mz）中有权限访问的全部名称”，那些被视为私有的变量或者函数或者类，则没有权限被访问。</p>
<p>再如</p>
<pre><code class="language-python">&gt;&gt;&gt; public_teacher()

  I am a public teacher, I am from JP.

&gt;&gt;&gt; _private_teacher()

Traceback (most recent call last):

  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;

NameError: name '_private_teacher' is not defined

</code></pre>
<p>但这也不是绝对的，我们可以通过一定会的方式来访问带有私有性质的东西</p>
<pre><code class="language-python">&gt;&gt;&gt; import mz

&gt;&gt;&gt; mz._private_teacher()

I am a private teacher, I am from CN.

&gt;&gt;&gt; mz._private_variable

'Hi, I am a private variable.'

</code></pre>
<p>然后在对mz.py进行修改：</p>
<pre><code class="language-python"># coding:utf-8


__all__ = ['_private_variable', 'public_teacher']


public_variable = &quot;Hello, I am a public variable.&quot;

_private_variable = &quot;Hi, I am a private variable.&quot;


def public_teacher():

    print(public_variable)


def _private_teacher():

        print(_private_variable)

</code></pre>
<p>在修改之后的 pp.py 中，增加了 __ all __ 变量以及相应的值，在列表中包含了一个私有变量的名字和一个函数的名字。这是在告诉引用本模块的解释器，这两个东西是有权限被访问的，而且只有这两个东西。</p>
<pre><code class="language-python">&gt;&gt;&gt; import sys

&gt;&gt;&gt; sys.path.append(&quot;~/Documents/StarterLearningPython/2code/pp.py&quot;)

&gt;&gt;&gt; from pp import *

&gt;&gt;&gt; public_variable
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'public_variable' is not defined

&gt;&gt;&gt; _private_variable
'Hi, I am a private variable.'

&gt;&gt;&gt; public_teacher()
Hello, I am a public variable.

&gt;&gt;&gt; _private_teacher()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name '_private_teacher' is not defined

</code></pre>
<p>可以看到不在__ all __ 中的变量都不再能被访问，而如果以 import mz 引入模块，再用mz. _ private_teacher的方式引用对私有变量也有效，这也是两种引用方式的区别。</p>
<h4 id="4-包和库">4.  包和库</h4>
<p>顾名思义，包和库都是比“模块”大的。一般来讲，一个“包”里面会有多个模块，当然，“库”是一个更大的概念了，比如 Python 标准库中的每个库都有好多个包，每个包都有若干个模块。</p>
<p>一个包由多个模块组成，即有多个.py 的文件，那么这个所谓的“包”就是我们熟悉的一个目录罢了。现在需要解决如何引用某个目录中的模块问题。解决方法就是在该目录中放一个 __ init __ .py 文件。__ init __.py 是一个空文件，将它放在某个目录中，就可以将该目录中的其他.py 文件作为模块被引用。</p>
<p>例如，建立一个目录，名曰：package_w，里面依次放了 hw.py 和 mz.py 两个文件，然后建立一个空文件 __ init __.py</p>
<p>接下来，需要导入这个包（package_w）中的模块,这里利用环境变量里已有的文件夹：C:\Users\wenxc\lib\site-packages</p>
<p>下面这种方法很清晰明了。</p>
<pre><code class="language-python">&gt;&gt;&gt; import package_w.hw

&gt;&gt;&gt; package_w.hw.display()

'hello world !'

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用HEXO构建个人博客]]></title>
        <id>https://wenxc.github.io/post/shi-yong-hexo-gou-jian-ge-ren-bo-ke/</id>
        <link href="https://wenxc.github.io/post/shi-yong-hexo-gou-jian-ge-ren-bo-ke/">
        </link>
        <updated>2019-08-01T13:58:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown （或其他渲染引擎）解析文章，利用靓丽的主题快速帮您生成静态网页，并可将网页按需求进行推送。文章记录笔者安装及使用过程中的一些问题及经验。参考网站：https://hexo.io/zh-cn/docs/</p>
</blockquote>
<!---more-->
<h3 id="准备">准备</h3>
<ul>
<li>node.js</li>
<li>git</li>
</ul>
<p>hexo基于node开发，下载地址 https://nodejs.org/en/，选择LTS版本即可<br>
git大家都比较熟悉，不多介绍。</p>
<h3 id="安装hexo">安装hexo</h3>
<p><strong>使用node command prompt 或gitbash</strong></p>
<p>使用npm安装软件包可能下载速度很慢，可以根据需要安装淘宝的cnpm，使用淘宝镜像库，减少安装时间。</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>后面的过程以cnpm为例，没有安装的直接以npm代替ncpm即可</p>
<p>安装hexo，查看hexo版本：</p>
<p><code>cnpm install -g hexo-cli</code></p>
<p><code>hexo -v</code></p>
<p>这一步成功说明hexo已成功安装，接下来就是制作自己的博客</p>
<h3 id="制作博客">制作博客</h3>
<p>构建博客框架</p>
<p>在合适的路径下生成博客文件夹</p>
<p><code>mdr blogname</code></p>
<p>在blog路径下初始化hexo，这里不同的环境稍有差异</p>
<ul>
<li>
<p>Windows环境下：</p>
<pre><code class="language-javascript">cd blog  
hexo  init
</code></pre>
</li>
<li>
<p>macOS环境下：</p>
<pre><code class="language-javascript">cd blog
sudo hexo init
</code></pre>
</li>
</ul>
<p>初始化后先将博客网页发布在本地：<code>hexo s</code> ，通过本地浏览器<code>localhost:4000</code>预览</p>
<p>此时是hexo的初始页面</p>
<figure data-type="image" tabindex="1"><img src="%E4%BD%BF%E7%94%A8HEXO%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/chushi.png" alt="chushi" loading="lazy"></figure>
<p>制作自己的博客内容</p>
<p><code>hexo new &quot;我的第一篇博客文章&quot;</code></p>
<figure data-type="image" tabindex="2"><img src="%E4%BD%BF%E7%94%A8HEXO%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.png" alt="我的第一篇博客文章" loading="lazy"></figure>
<p>新的文章存储在source/_post 路径下, 使用文本或typora对文章进行编辑，再发布：</p>
<p><code>hexo clean &amp;&amp; g &amp;&amp; s</code></p>
<p>重新发布前一定要先把原来的数据清除，否则可能会出现更新不及时或内容无法上传等情况</p>
<h3 id="远程部署">远程部署</h3>
<p>hexo生成的博客网页可以直接发布到网站，也可以部署到自己github，推荐使用github</p>
<p>建立github仓库，把文章部署到自己的仓库<br>
在新建仓库时需注意仓库的第一字段必须与owner相同。博客建成后，仓库链接就可以用作分享链接。<br>
<img src="%E4%BD%BF%E7%94%A8HEXO%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="新建仓库" loading="lazy"></p>
<blockquote>
<p>hexo框架的博客有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong></p>
</blockquote>
<p>修改站点配置文件 Deployment 部分，填写 deploy ：</p>
<blockquote>
<p>deploy:<br>
type: git</p>
<p>repo: https://github.com/Wenxc/Wenxc.github.io</p>
<p>branch: master</p>
</blockquote>
<p>安装部署插件：</p>
<p><code>cnpm install --save hexo-deployer-git</code></p>
<p>把博客部署到仓库：</p>
<p><code>hexo d</code></p>
<blockquote>
<p>Windows环境直接推送可能会报错，这是因为没有指定邮箱和用户名，部署前先配置GitHub帐户<br>
git config --global user.email &quot;you@example.com&quot;<br>
git config --global user.name &quot;Your Name&quot;</p>
</blockquote>
<p>然后再重新执行部署，成功后新建的仓库内就能看到博客<br>
<img src="%E4%BD%BF%E7%94%A8HEXO%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%8E%A8%E9%80%81%E6%88%90%E5%8A%9F.png" alt="部署成功" loading="lazy"></p>
<p>这时就可以通过分享github pages 让别人快速访问你的博客了。</p>
<hr>
<h3 id="主题美化">主题美化</h3>
<p>前面步骤只是搭建出了个人博客，对个人博客的美化和内容填充是一个日积月累的过程，慢慢来。<br>
这里推荐4款github上分享的主题</p>
<blockquote>
<p>https://github.com/litten/hexo-theme-yilia</p>
<p>https://github.com/litten/hexo-theme-mellow</p>
<p>https://github.com/litten/hexo-theme-next</p>
<p>https://github.com/litten/hexo-theme-concise</p>
</blockquote>
<p>以yilia为例，克隆到本地或直接下载后解压到themse文件夹内</p>
<pre><code class="language-javascript">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia
</code></pre>
<p>配置参数文件</p>
<p>在站点配置文件Extensions部分，将theme的landscape改为yilia</p>
<blockquote>
<p>Plugins: https://hexo.io/plugins/<br>
Themes: https://hexo.io/themes/<br>
theme: landscape</p>
</blockquote>
<p>然后清除缓存，更新数据库发布，部署到仓库。（每次更新数据前必须清理缓存）</p>
<p><code>hexo clean &amp;&amp; g &amp;&amp; s hexo d</code></p>
]]></content>
    </entry>
</feed>